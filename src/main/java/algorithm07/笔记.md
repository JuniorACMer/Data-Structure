# AES算法
***
* 问：什么是AES算法？
* 答：AES算法是典型的对称加密算法。算法全称Advanced Encryption Standard，是DES算法的代替者。
***
* 问：AES算法工作步骤
* 答：1、发送方利用密钥123456，加密明文“我是小灰”，加密结果为TNYRvx+SNjZwEK+ZXFEcDw==。
    2、发送方吧加密还有得内容TNYRvx+SNjZwEK+ZXFEcDw==传输给接收方。
    3、接收方收到密文TNYRvx+SNjZwEK+ZXFEcDw==，利用密钥123456还原明文“我是小灰”。
***
* 问：摘要算法和对称加密算法得区别？
* 答：摘要算法不可逆，他的主要作用是对信息一致性和完整性的校验。
    对称算法可逆，它的主要作用是保证私密信息不被泄露。
***
* 问：AES算法的基本概念。
* 答：1、密钥。密钥是AES算法实现加密和解密的根本，对称算法之所以对称，是因为这类算法对明文的加密和解密需要同一个密钥。
        AES支持三种长度的密钥 128位、192位、256位。
        从安全性来看，AES256安全性最高，从性能上来看，AES128性能最高。本质原因是它们加密处理轮数不同。
    2、填充。AES分组加密的时候，如果最后一个明文块位数不足，则对明文块进行填充（Padding）。
    3、模式。AES工作模式，体现在把明文块加密成密文块的处理过程中。AES加密算法提供五种不同的工作模式。ECB、CBC、CTR、CFB、OFB，模式之间的主题思想是近似的。
***
* 问：什么是AES的分组加密特性？
* 答：AES算法对明文加密的时候并不是把整个明文一股脑加密成一整段密文，而是把明文拆分成一个个独立的明文块，每一个明文块长度位128bit。这些明文块经过AES加密器的复杂处理，
    生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。
***
* 问：AES典型的填充算法介绍。
* 答：1、NoPadding。不做任何填充，但是要求明文是16字节的整数倍。
    2、PKCS5Padding（默认）。如果明文块少于16个字节（128位），在明文块末尾补足相应数量的字节，且每个字节的值等于缺少的字符数。
    3、ISO10126Padding。如果明文块少于16个字节（128位），在明文块末尾补足相应数量的字节，最后一个字符值等于缺少的字符数，其他字符填充随机数。
    注意：AES加密和解密必须使用同一种填充方式。
***
* 问：AES算法工作模式的种类和其基本定义。
* 答：1、ECB模式（默认）。电话本模式（Electronic Codebook Book）。
    2、CBC模式。密文分组连接模式（Cipher Block Chaining）。
    3、CTR模式。计算器模式（Counter）。
    4、CFB模式。密码反馈模式（Cipher FeedBack）。
    5、OFB模式。输出反馈模式（Output FeedBack）。
    注意：AES加密和解密必须使用同一种工作模式。
***
* 问：AES算法在java中的封装。
* 答：

# A* 寻路算法 A* Search
<u>应用场景：迷宫寻路游戏，绕过障碍物直达终点</u>
***
* 问：什么是A* 寻路算法？
* 答：A* 寻路算法，英文名：A* Search，是一种用于寻找有效路径的算法。
***
* 问：一个公式的引入。
* 答：[OpenList] [CloseList] 
    [F = G + H]
    OpenList和CloseList都是存储格子的集合，其中OpenList存储可到达的格子，CloseList存储已到达的格子。
    公式： [F = G + H]，是对格子价值的评估，其中G代表从起点走到当前格的成本，也就是走了多少步。
    H代表从当前格走到目标格的距离，也就是不考虑障碍的情况下，距离目标还有多远。
    F是对G和H的综合评估。F的值越小越好。

# BitMap算法 位图算法
<u>应用场景：用于对大量整型数据做去重和查询</u>
***
* 问：Bitmap算法的主要用途？
* 答：可以用来存储大量的用户ID，在插入数据到数据库中的时候。
***
* 问：什么是位图算法？
* 答：这里所说的位图不是像素图片，而是内存中连续的二进制位(bit)，用于对大量整型数据做去重和查询。ID对应Bitmap中的下标值，例如
      ID=8，则把第八位置为1。
      Long类型的数组，一个word存储64个ID，Int类型的存储32个ID。
***
* 问：BitMap算法的优缺点？
* 答： 优点：
       1. 节省内存的存储空间。例如使用HashSet或HashMap，用户ID需要占用四个字节，而BitMap中只占用一个bit。
       2. 位运算的高性能。
       缺点：不支持非运算。比如查找不适用Iphone手机的用户，BitMap就无能为力了。
***
* 问：开源的BitMap实现方式？
* 答：1. JDK中的BitSet集合是对Bitmap算法相对简单的实现。2.谷歌开发的EWAHCompressedBitMap是一种更为优化的实现。
***
* 问：如何使用Bitmap进行非运算？
* 答：例如：查找所有属于90后的用户。首先，给出一个全量用户，其次，查询所有的90后用户，最后，与全量用户做抑或操作。
***
* 问：如果在一个很长的Bitmap里，只有一个用户，岂不是浪费空间？
* 答：谷歌事项的EWAHCompressedBitmap中，对Bitmap存储空间做了一定的优化。
***
* 问：Bitmap的存储方式？
* 答：EWAH把Bitmap存储与long数组中，long数组的每一个元素都以当作是64位的二进制数，也是整个Bitmap的子集。谷歌把这些子集叫做word。
***
* 问：在一个Bitmap中存在多少个Word？
* 答：当创建一个空的Bitmap时，初始只有四个Word，也即是long数组的长度是4，随着数据的不断插入，word量 随之扩充。word0不直接存储数据。
***
* 问：Word分为哪两种？
* 答：直接存储数据的叫Literal Word，简称LW。存储跨度信息的叫Running Length Word，简称RLW。
      每一个RLW分成两部分，低32位表示当前Word横跨了多少空Word，高32位表示当前RLW后方有多少个连续的LW。
***
* 问：既然Bitmap里有些word是存储数据的，有些Word是跨度信息的，当一个新数据插入的时候，如何正确的位置呢？
* 答：比如我们要插入的新ID是400003，寻找位置的过程如下：
        1. 解析Word0，得知当前RLW横跨的空Word数量为0，后面又连续三个普通的Word。
        2. 计算出当前RLW后方连续普通Word的最大ID是64*（0+3）-1=191
        3. 由于191 < 400003，所以新ID必然在下一个RLW(Word4)之后。
        4. 解析Word4，得知当前RLW横跨的空Word数量为6247，后面又连续一个普通Word。
        5. 计算出当前RLW（Word4）后方连续普通Word的最大ID是191+（6247+1）*64 =  400063.
        6. 由于400003 < 4000063，因此新ID400003的正确位置就在当前RLW(Word4)的后方普通Word，也就是Word5当中。
        如果插入的ID是200000，过程如下：
        在RLW中间插入数值的时候会涉及部分Word的移位，影响性能，所以谷歌官方建议使用者从小到大来杀入数据。
***
* 问：开发Bitmap所需依赖如下。
* 答：EWAHCompressedBitmap对应的maven依赖如下：
  
    
    <dependency>
      <groupId>com.googlecode.javaewah</groupId>
      <artifactId>JavaEWAH</artifactId>
      <version>1.1.7</version>
    </dependency>
    
    
# 布隆算法

<u>应用场景举例：网络爬虫爬取的URL去重</u>
***
* 问：URL去重方案第一版：HashSet
* 答：做法：创建一个HashSet集合，把每一个URL字符串作为HashSet的Key插入到集合当中，利用HashSet的Key的唯一性对URL做去重。
      造成的问题：HashSet占用内存太多。
***
* 问：URL去重第二版：Bitmap
* 答：做法:获取每一个URL的HashCode，根据HashCode的值来插入到Bitmap的对应位置。如果要插入的为值已经是1，说明该URL已重复。
      造成的问题：字符串的HashCode是会有重复的，不同URL的HashCode很可能相同。String的HashCode方法，
***
* 问：什么是Bloom算法？
* 答：布隆算法是由BloomFilter音译而来，是一种以Bitmap集合为基础的排重算法。
***
* 问：Bloom算法的具体流程。
* 答：1. 创建一个空的Bitmap集合。
      2. 把第一个URL按照三种Hash算法，分别生成三个不同的Hash值。
      3. 分别判断在Bitmap对应位置是否为1，只要不同时为1，就认为URL没有重复，于是把对应位置设置为1.
      4. 把第二个URL按照三种Hash算法，分别生成三个不同的Hash值。
      5. 分别判断在Bitmap对应位置是否为1，只要不同时为1，就认为URL没有重复，于是把对应位置设置为1.
      。。。
***
* 问：Bloom算法的缺点。
* 答：会造成误判，布隆算法虽然极力降低了Hash冲突的几率，但是仍然有一定的误判率。为了减小误判的几率，可以让Bitmap的空间更大一些
      单个URL所做的hash更多一些，一般是8次，总是是在空间和准确率上做出取舍。
***
* 问：如何杜绝误判？
* 答：可以考虑加上一个白名单，专门存储那些被误判的结果。
***

# 一些常用算法的实现
***
## 如何判断链表有环？
* 问：如问题所示，解决办法如下。
* 答：创建两个指针1和2，同时指向这个链表的头节点。然后开始一个大循环，在循环中，让指针1每次向下移动一个节点，
      指针2每次向下移动两个节点然后比较两个指针指向的节点是否相同。如果相同则判断链表有环，如果不同则继续。
      这类似于环形跑道上，两个运动员，一个跑的块，一个跑的慢，最终速度快的运动员，必然会再次追上速度慢的运动员。
      原因很简单，因为跑到时环形的。
***
## 求最大公约数
* 问：辗转相除法--求最大公约数（Greatest Common Divisor）。
* 答：辗转相除法，又名为欧几里得算法，目的是求出两个整数的最大公约数。
      定理：连个正整数a和b(a>b)，它们的最大公约数等于a除以b的余数c和b之间的最大公约数。
      逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两个数可以整除，或者其中一个数减小到1为止。
       public static int gcd(int a, int b) {
              if (a % b == 0) {
                  return b;
              } else {
                  return (gcd(b, a % b));
              }
       缺点：取模运算性能太低。
***
* 问：更相减损术--求最大公约数。
* 答：出自中国古代的《九章算术》，目的是求最大公约数。
      原理：两个正整数a和b(a>b)，它们的最大公约数等于a-b的差值c和较小数b的最大公约数。
      直到两个数可以相等为止，最大公约数就是最终相等的两个数。
      public static int gcd2(int a, int b) {
              if (a == b) {
                  return a;
              }
              if (a > b) {
                  return gcd2(a - b, b);
              } else {
                  return gcd2(b - a, a);
              }
          }
      缺点：更相减损术时不稳定的算法，当两数相差悬殊时，比如计算10000和1，就要递归9999次。
***
* 问：如何把辗转相除法和更相减损术的优势结合起来？
* 答：在更相减损术的基础上使用移位运算。
***
* 问：
* 答：
***
## 找出缺失得整数
***
* 问：一个无序数组里有99个不重复正整数，范围从1到100，唯独缺少一个整数。如何找出这个缺失得整数？
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
## volatile关键字。
***
* 问：什么是java内存模型？
* 答：java内存模型简称JMM（Java Memory Model），是java虚拟机所定义的一种抽象规范，用来屏蔽不同一件和操作系统的内存访问差异，让java程序在各种
       平台下都能达到一致的内存访问效果。
***
* 问：什么是主内存？
* 答：主内存可以简单理解为计算机当中的内存，但又不完全等同。主内存被所有的线程所共享，对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，
      主内存中存储了它的“本尊”。
***
* 问：什么是工作内存？
* 答：工作内存可以简单理解为计算机当中的CPU高速缓存，但又不完全等同。每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。
      线程对共享变量的所有操作必须在工作内存中进行，不能直接读写主内存中的变量。不同线程之间也无法访问彼此的工作内存，变量值的传递只能通过主内存来进行。
      这将导致一个问题：两个线程同时操作内存中的静态变量，由于工作中内存所更新的变量并不会立即同步到主内存，导致结果不一致。
***
* 问：如何解决线程操作堆内存数据导致的数据不一致问题？
* 答：同步锁虽然可以保证线程安全，当时对程序的影响太大了，有一种轻量级的解决方法volatile。
***
* 问：volatile关键字的可见性。
* 答：保证用volatile修饰的变量对所有线程的可见性。当一个线程修改了变量的值，新的值会立刻同步到主内存当中。而其他线程读取这个变量的时候，也会从内存中拉取
      最新的变量值。
***
* 问：为什么volatile关键字可以有这样的特性呢：
* 答：这得益于java语言的先行发生原则。在计算机科学中，先行发生原则是两个事件的结果之间的关系，如果一个事件发生在另一个事件之前，结果必须反映，
      即使这些事件实际上是乱序执行的（通常是优化程序流程）。这里所谓的事件其实就是各种指令操作，例如读、写、初始化锁操作等等。
      volatile特性之一：
      保证变量在线程之间的可见性。可见性的保证是基于CPU的内存屏障指令，被JSR-133抽象为happens-before原则。
      volatile特性之二：
      阻止编译时和运行时的指令重排。编译时JVM编译器遵循内存屏障的约束，运行时依靠CPU屏障指令来阻止重排。
      volatile除了保证可见性和阻止指令重排，还解决了long类型和double类型数据的8字节赋值问题。
***
* 问：volatile只能保证变量的可见性，并不能保证变量的原子性。
* 答：见示例VolatileTest.java。其中count++这一行代码并不是原子性操作，在字节码层面可以拆分成如下指令：
      getstatic      //读取静态变量（count）
      iconst_1       //定义常量1
      iadd           //count增加1
      putstatic      //把count结果同步到主内存 
      虽然么一次执行getstatic的时候，获取到的都是主内存最新变量值，但是进行iadd的时候，由于并不是原子性操作，其他线程在这过程中很可能让count自增了很多次。
      这样一来本线程所计算更新的是一个陈旧的count值，自然无法做到线程安全。
***
* 问：什么时候适合使用volatile关键字？
* 答：1. 运行结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。见以上示例。
      2. 变量不需要与其他的状态变量共同参与不变约束。
***
* 问：什么是指令重排？
* 答：指令重排是指JVM在编译java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。指令重排的目的是为了在不改变程序执行结果的前提下，
      优化程序的运行效率。这里所说的不改边执行结果，指的是不改变单线程下的程序执行结果。
***
* 问：什么是内存屏障？
* 答：内存屏障（Memory Barrier）是一种CPU指令，维基百科给出了如下定义：
      内存屏障也称为内存栅栏或栅栏指令，是一种屏障指令，它使CPU或编译器对屏障指令之前和之后发出的内存操作执行一个排序约束。 
      这通常意味着在屏障之前发布的操作被保证在屏障之后发布的操作之前执行。
      内存屏障共分为四种类型：   
      
      
      LoadLoad屏障：
      抽象场景：Load1; LoadLoad; Load2
      Load1 和 Load2 代表两条读取指令。在Load2要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
      StoreStore屏障：
      抽象场景：Store1; StoreStore; Store2
      Store1 和 Store2代表两条写入指令。在Store2写入执行前，保证Store1的写入操作对其它处理器可见
      LoadStore屏障：
      抽象场景：Load1; LoadStore; Store2
      在Store2被写入前，保证Load1要读取的数据被读取完毕。
      StoreLoad屏障：
      抽象场景：Store1; StoreLoad; Load2
      在Load2读取操作执行前，保证Store1的写入对所有处理器可见。StoreLoad屏障的开销是四种屏障中最大的。
***
* 问：volatile做了什么？
* 答：在一个变量被volatile修饰后，jvm会为我们做两件事：
      1. 在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障。
      2. 在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障。
***
* 问：内存屏障和先行发生原则的关系？
* 答：happens-before是JSR-133规范之一，内存屏障是CPU指令，前者是最终目的，后者是手段。
***
## transient关键字
***
* 问：什么是transient关键字？
* 答：java语言的关键字，变量修饰符，如果transient声明一个变量，当对象存储时，它的值不需要维持。换句话说：transient关键字标记的成员变量不参与序列化过程。
***
* 问：transient关键字的作用？
* 答：java的serialization提供了一种持久化对象的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保护它。为了在一个特定
      对象的一个域上关闭serialization，可以在这个域前加上关键字transient。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然后非
      transient型的变量是被包括进去的。
***
* 问：为什么有了transient关键字？
* 答：JDK源码中很多地方都会加上transient关键字，可能是为了节约磁盘空间。
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：