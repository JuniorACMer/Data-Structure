# AES算法
***
* 问：什么是AES算法？
* 答：AES算法是典型的对称加密算法。算法全称Advanced Encryption Standard，是DES算法的代替者。
***
* 问：AES算法工作步骤
* 答：1、发送方利用密钥123456，加密明文“我是小灰”，加密结果为TNYRvx+SNjZwEK+ZXFEcDw==。
    2、发送方吧加密还有得内容TNYRvx+SNjZwEK+ZXFEcDw==传输给接收方。
    3、接收方收到密文TNYRvx+SNjZwEK+ZXFEcDw==，利用密钥123456还原明文“我是小灰”。
***
* 问：摘要算法和对称加密算法得区别？
* 答：摘要算法不可逆，他的主要作用是对信息一致性和完整性的校验。
    对称算法可逆，它的主要作用是保证私密信息不被泄露。
***
* 问：AES算法的基本概念。
* 答：1、密钥。密钥是AES算法实现加密和解密的根本，对称算法之所以对称，是因为这类算法对明文的加密和解密需要同一个密钥。
        AES支持三种长度的密钥 128位、192位、256位。
        从安全性来看，AES256安全性最高，从性能上来看，AES128性能最高。本质原因是它们加密处理轮数不同。
    2、填充。AES分组加密的时候，如果最后一个明文块位数不足，则对明文块进行填充（Padding）。
    3、模式。AES工作模式，体现在把明文块加密成密文块的处理过程中。AES加密算法提供五种不同的工作模式。ECB、CBC、CTR、CFB、OFB，模式之间的主题思想是近似的。
***
* 问：什么是AES的分组加密特性？
* 答：AES算法对明文加密的时候并不是把整个明文一股脑加密成一整段密文，而是把明文拆分成一个个独立的明文块，每一个明文块长度位128bit。这些明文块经过AES加密器的复杂处理，
    生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。
***
* 问：AES典型的填充算法介绍。
* 答：1、NoPadding。不做任何填充，但是要求明文是16字节的整数倍。
    2、PKCS5Padding（默认）。如果明文块少于16个字节（128位），在明文块末尾补足相应数量的字节，且每个字节的值等于缺少的字符数。
    3、ISO10126Padding。如果明文块少于16个字节（128位），在明文块末尾补足相应数量的字节，最后一个字符值等于缺少的字符数，其他字符填充随机数。
    注意：AES加密和解密必须使用同一种填充方式。
***
* 问：AES算法工作模式的种类和其基本定义。
* 答：1、ECB模式（默认）。电话本模式（Electronic Codebook Book）。
    2、CBC模式。密文分组连接模式（Cipher Block Chaining）。
    3、CTR模式。计算器模式（Counter）。
    4、CFB模式。密码反馈模式（Cipher FeedBack）。
    5、OFB模式。输出反馈模式（Output FeedBack）。
    注意：AES加密和解密必须使用同一种工作模式。
***
* 问：AES算法在java中的封装。
* 答：

# A* 寻路算法 A* Search
<u>应用场景：迷宫寻路游戏，绕过障碍物直达终点</u>
***
* 问：什么是A* 寻路算法？
* 答：A* 寻路算法，英文名：A* Search，是一种用于寻找有效路径的算法。
***
* 问：一个公式的引入。
* 答：[OpenList] [CloseList] 
    [F = G + H]
    OpenList和CloseList都是存储格子的集合，其中OpenList存储可到达的格子，CloseList存储已到达的格子。
    公式： [F = G + H]，是对格子价值的评估，其中G代表从起点走到当前格的成本，也就是走了多少步。
    H代表从当前格走到目标格的距离，也就是不考虑障碍的情况下，距离目标还有多远。
    F是对G和H的综合评估。F的值越小越好。

# BitMap算法 位图算法
<u>应用场景：用于对大量整型数据做去重和查询</u>
***
* 问：Bitmap算法的主要用途？
* 答：可以用来存储大量的用户ID，在插入数据到数据库中的时候。
***
* 问：什么是位图算法？
* 答：这里所说的位图不是像素图片，而是内存中连续的二进制位(bit)，用于对大量整型数据做去重和查询。ID对应Bitmap中的下标值，例如
      ID=8，则把第八位置为1。
      Long类型的数组，一个word存储64个ID，Int类型的存储32个ID。
***
* 问：BitMap算法的优缺点？
* 答： 优点：
       1. 节省内存的存储空间。例如使用HashSet或HashMap，用户ID需要占用四个字节，而BitMap中只占用一个bit。
       2. 位运算的高性能。
       缺点：不支持非运算。比如查找不适用Iphone手机的用户，BitMap就无能为力了。
***
* 问：开源的BitMap实现方式？
* 答：1. JDK中的BitSet集合是对Bitmap算法相对简单的实现。2.谷歌开发的EWAHCompressedBitMap是一种更为优化的实现。
***
* 问：如何使用Bitmap进行非运算？
* 答：例如：查找所有属于90后的用户。首先，给出一个全量用户，其次，查询所有的90后用户，最后，与全量用户做抑或操作。
***
* 问：如果在一个很长的Bitmap里，只有一个用户，岂不是浪费空间？
* 答：谷歌事项的EWAHCompressedBitmap中，对Bitmap存储空间做了一定的优化。
***
* 问：Bitmap的存储方式？
* 答：EWAH把Bitmap存储与long数组中，long数组的每一个元素都以当作是64位的二进制数，也是整个Bitmap的子集。谷歌把这些子集叫做word。
***
* 问：在一个Bitmap中存在多少个Word？
* 答：当创建一个空的Bitmap时，初始只有四个Word，也即是long数组的长度是4，随着数据的不断插入，word量 随之扩充。word0不直接存储数据。
***
* 问：Word分为哪两种？
* 答：直接存储数据的叫Literal Word，简称LW。存储跨度信息的叫Running Length Word，简称RLW。
      每一个RLW分成两部分，低32位表示当前Word横跨了多少空Word，高32位表示当前RLW后方有多少个连续的LW。
***
* 问：既然Bitmap里有些word是存储数据的，有些Word是跨度信息的，当一个新数据插入的时候，如何正确的位置呢？
* 答：比如我们要插入的新ID是400003，寻找位置的过程如下：
        1. 解析Word0，得知当前RLW横跨的空Word数量为0，后面又连续三个普通的Word。
        2. 计算出当前RLW后方连续普通Word的最大ID是64*（0+3）-1=191
        3. 由于191 < 400003，所以新ID必然在下一个RLW(Word4)之后。
        4. 解析Word4，得知当前RLW横跨的空Word数量为6247，后面又连续一个普通Word。
        5. 计算出当前RLW（Word4）后方连续普通Word的最大ID是191+（6247+1）*64 =  400063.
        6. 由于400003 < 4000063，因此新ID400003的正确位置就在当前RLW(Word4)的后方普通Word，也就是Word5当中。
        如果插入的ID是200000，过程如下：
        在RLW中间插入数值的时候会涉及部分Word的移位，影响性能，所以谷歌官方建议使用者从小到大来杀入数据。
***
* 问：开发Bitmap所需依赖如下。
* 答：EWAHCompressedBitmap对应的maven依赖如下：
  
    
    <dependency>
      <groupId>com.googlecode.javaewah</groupId>
      <artifactId>JavaEWAH</artifactId>
      <version>1.1.7</version>
    </dependency>
    
    
# 布隆算法

<u>应用场景举例：网络爬虫爬取的URL去重</u>
***
* 问：URL去重方案第一版：HashSet
* 答：做法：创建一个HashSet集合，把每一个URL字符串作为HashSet的Key插入到集合当中，利用HashSet的Key的唯一性对URL做去重。
      造成的问题：HashSet占用内存太多。
***
* 问：URL去重第二版：Bitmap
* 答：做法:获取每一个URL的HashCode，根据HashCode的值来插入到Bitmap的对应位置。如果要插入的为值已经是1，说明该URL已重复。
      造成的问题：字符串的HashCode是会有重复的，不同URL的HashCode很可能相同。String的HashCode方法，
***
* 问：什么是Bloom算法？
* 答：布隆算法是由BloomFilter音译而来，是一种以Bitmap集合为基础的排重算法。
***
* 问：Bloom算法的具体流程。
* 答：1. 创建一个空的Bitmap集合。
      2. 把第一个URL按照三种Hash算法，分别生成三个不同的Hash值。
      3. 分别判断在Bitmap对应位置是否为1，只要不同时为1，就认为URL没有重复，于是把对应位置设置为1.
      4. 把第二个URL按照三种Hash算法，分别生成三个不同的Hash值。
      5. 分别判断在Bitmap对应位置是否为1，只要不同时为1，就认为URL没有重复，于是把对应位置设置为1.
      。。。
***
* 问：Bloom算法的缺点。
* 答：会造成误判，布隆算法虽然极力降低了Hash冲突的几率，但是仍然有一定的误判率。为了减小误判的几率，可以让Bitmap的空间更大一些
      单个URL所做的hash更多一些，一般是8次，总是是在空间和准确率上做出取舍。
***
* 问：如何杜绝误判？
* 答：可以考虑加上一个白名单，专门存储那些被误判的结果。
***

# 一些常用算法的实现
***
## 如何判断链表有环？
* 问：如问题所示，解决办法如下。
* 答：创建两个指针1和2，同时指向这个链表的头节点。然后开始一个大循环，在循环中，让指针1每次向下移动一个节点，
      指针2每次向下移动两个节点然后比较两个指针指向的节点是否相同。如果相同则判断链表有环，如果不同则继续。
      这类似于环形跑道上，两个运动员，一个跑的块，一个跑的慢，最终速度快的运动员，必然会再次追上速度慢的运动员。
      原因很简单，因为跑到时环形的。
***
## 求最大公约数
* 问：辗转相除法--求最大公约数（Greatest Common Divisor）。
* 答：辗转相除法，又名为欧几里得算法，目的是求出两个整数的最大公约数。
      定理：连个正整数a和b(a>b)，它们的最大公约数等于a除以b的余数c和b之间的最大公约数。
      逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两个数可以整除，或者其中一个数减小到1为止。
       public static int gcd(int a, int b) {
              if (a % b == 0) {
                  return b;
              } else {
                  return (gcd(b, a % b));
              }
       缺点：取模运算性能太低。
***
* 问：更相减损术--求最大公约数。
* 答：出自中国古代的《九章算术》，目的是求最大公约数。
      原理：两个正整数a和b(a>b)，它们的最大公约数等于a-b的差值c和较小数b的最大公约数。
      直到两个数可以相等为止，最大公约数就是最终相等的两个数。
      public static int gcd2(int a, int b) {
              if (a == b) {
                  return a;
              }
              if (a > b) {
                  return gcd2(a - b, b);
              } else {
                  return gcd2(b - a, a);
              }
          }
      缺点：更相减损术时不稳定的算法，当两数相差悬殊时，比如计算10000和1，就要递归9999次。
***
* 问：如何把辗转相除法和更相减损术的优势结合起来？
* 答：在更相减损术的基础上使用移位运算。
***
* 问：
* 答：
***
## 找出缺失得整数
***
* 问：一个无序数组里有99个不重复正整数，范围从1到100，唯独缺少一个整数。如何找出这个缺失得整数？
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：
***
* 问：
* 答：