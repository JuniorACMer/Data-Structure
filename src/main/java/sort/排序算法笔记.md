==============================================================================================
问：第三梯队排序算法的稳定性和性能。（第三梯队：冒泡、选择、插入）
答：当原始数组接近有序时，插入排序性能最优；当原始数组大部分元素无序时，选择排序性能最优。
    冒泡排序和插入排序时稳定排序，值相同的元素在排序后任然保持原本的先后顺序。
    选择排序时不稳定排序，值相同的元素在排序后，不一定保持原本的先后顺序。
==============================================================================================

以下是第二梯队排序算法

================================================================================================
问：什么是希尔排序？
答：希尔排序是直接插入排序的升级版。像这样逐步分组进行粗调，再进行直接插入排序的思想，就是希尔排序，根据该算法的发明者，
    计算机科学家Donald Shell的名字所命名。希尔排序不是稳定排序。

问：怎样可以对插入排序算法优化呢？
答：首先明确插入排序的两个缺点：
    1、在大多数元素已经有序的情况下，插入排序的工作量较小。
    2、在元素数量较少的情况下，插入排序的工作量较小。
    对原始数据进行一些预处理，使的原始数组的大部分元素变得有序：
    分组排序方法：让元素两两一组，同组两个元素之间的跨度，都是数组总长度的一半，也就是跨度为4。
    进一步缩小分组跨度为2，重新对元素分组。
    让每组元素进行独立排序，排序方式用直接插入排序即可。
    最后把分组跨度进一步减小为1，也就等同于做直接插入排序。
    
问：增量。
答：分组跨度被称为希尔排序的增量，增量的选择可以由很多种，逐步折半的增量方法，使希尔在发明希尔排序时提出的一种朴素方法，
    被称为写入增量。

问：写入排序的优缺点？
答：利用分组粗调的方式减少了直接插入排序的工作量，是的算法的平均时间复杂度低于O(n^2)，但是在某些极端的情况下，希尔排序的最坏时间复杂度仍然
    是O(n^2)，甚至比插入排序更慢。例如分组之后，每一组前者都比后者要小，白白增加了分组成本。

问：如何为希尔排序选择更有效的增量方式？
答：Hibbard的增量序列如下：1，3，4，15...通项公式：2^k-1，利用此种增量方式的希尔排序，最坏的时间复杂度是O(n^(3/2))
    Sedgewick的增量序列如下：1，5，19，41...通项公式：9*4^k-9*2^k+1或者4^k-3*2^k+1，利用此种增量方式的希尔排序，最坏的时间复杂度是O(n^(4/3))

================================================================================================
问：什么是快速排序？
答：快速排序是从冒泡排序演变而来的算法，但是比冒泡排序要高效的多，所以叫做快速排序。快速排序之所以快速，是因为它使用了分治法。
    不同的是，冒泡排序在每一轮只把一个元素冒泡到数列的一端，而快速排序挑选一个基准元素，并让其他比他大的元素移动到数列一边，
    比它小的元素移动到数列的另一边，从而把数列拆成了两个部分。这种思路就叫做分治法。在分治法的思想下，原数列在每一轮被拆分成两部分，
    每一部分在下一轮又分别被拆分成两部分，直到不可再分为止。这样一共需要多少轮呢？
    平均情况下需要logn轮，因此快速排序算法的平均时间复杂度是 O（nlogn）。

问：如何选取基准元素？
答：1、最简单的方式就是选择数列的第一个元素。在已经有序的数列中，快速排序需要经过N轮，时间复杂度退化成了O（n^2）。
    2、随机选择一个元素作为基准元素。
    即使如此，每一次也有绩效的纪律选择到数列的最大最小值，影响分治的效果，所以,
    快速排序的平均时间复杂度是O（nlogn），最坏情况下的时间复杂度为O（n^2）。

问：选定基准元素后，如何移动元素有两种方法？
答：1、挖坑法。
        1、选定基准元素Pivot，并记住这个位置index，这个位置相当于一个坑，并且设置两个指针left和right，指向数列的最左和最右两个元素。
        2、从right指针开始，把指针所指向的元素和基准元素作比较。如果比pivot大，则right指针向左移动；
            如果比pivot小，则把right所指向的元素填入坑中。同时left指针向右移动一位。
        3、接下来，切换到left指针进行比较。如果left指向的元素小于pivot，则left指针向右移动；如果元素大于pivot，则把left指向的元素填入坑中。
        
    2、指针交换法。

问：
答：
问：
答：
问：
答：

问：
答：

问：
答：

问：
答：

问：
答：
问：
答：
问：
答：
问：
答：
问：
答：
问：
答：



